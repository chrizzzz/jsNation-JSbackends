// scalierung funktioniert ein bisschen anders
// da es keine threads gibt sonder nur eins
// can I split it up/when not use another language
// how many worker thread can I have/// how many e.g. in Java

// express.js/fastify
// socket.io
// nest.js
// why Typescript, when, when not

// lambdas
// generall adivce :  - split things up / fighting against monoliths
//                    - testing
//                    - properties from the outside

// how are we scaling, can we calculate scaling better with JS
// communication between services
// message broker, zookeper, proxies

// entkopplung
// kommunikation between services
// connection lose
// service shutdown
// reliablity
// interfaces

// docker, kubernetes, openstack

// need health endpoint

// authentication
// encryption
// backends, not only UI-Backends or faceades

// less configuration and overhead
// more controll over feature

// Let's write a backend
// what should I take into consideration
// health enpoint
// underlying services/error handling
// enviroment properties from the outside world
// logging/tracing

// If you like TypeScript, why not nest.js?

// So es6 oder Typescript?
// Do what you like and is the best for the app
// But I don't want rest. I want to stream data?(socket.io)

// How about functional lambdas -> but that is another talk =)
